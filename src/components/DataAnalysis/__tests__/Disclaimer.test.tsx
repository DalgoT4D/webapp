import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Disclaimer } from '../Disclaimer'; // Update the path as needed
import { httpPut } from '@/helpers/http';
import { useSession } from 'next-auth/react';
import { errorToast } from '@/components/ToastMessage/ToastHelper';

jest.mock('@/helpers/http', () => ({
  httpPut: jest.fn(),
}));

jest.mock('next-auth/react', () => ({
  useSession: jest.fn(),
}));

jest.mock('@/components/ToastMessage/ToastHelper', () => ({
  errorToast: jest.fn(),
}));

describe('Disclaimer Component', () => {
  beforeEach(() => {
    (useSession as jest.Mock).mockReturnValue({
      data: {
        user: {
          email: 'test@example.com',
        },
      },
    });
  });

  it('should render the disclaimer dialog', () => {
    const setIsOpen = jest.fn();

    render(<Disclaimer open={true} setIsOpen={setIsOpen} isOrgPrefernce={false} />);

    // Check if the disclaimer title is rendered
    expect(screen.getByText('Disclaimer')).toBeInTheDocument();
    // Check if the disclaimer text is rendered
    expect(
      screen.getByText(
        /this content has been generated by an artificial intelligence language model, and it is provided as-is without any warranties or guarantees of accuracy/i
      )
    ).toBeInTheDocument();
  });

  it('should call handleUserPreference and close the dialog on successful API call when isOrgPrefernce is false', async () => {
    const setIsOpen = jest.fn();
    (httpPut as jest.Mock).mockResolvedValue({ success: true });

    render(<Disclaimer open={true} setIsOpen={setIsOpen} isOrgPrefernce={false} />);

    // Simulate clicking the "Okay" button
    const okayButton = screen.getByText('Okay');
    fireEvent.click(okayButton);

    // Wait for the API call and dialog close
    await waitFor(() => {
      expect(httpPut).toHaveBeenCalledWith(
        { user: { email: 'test@example.com' } },
        'userpreferences/',
        { disclaimer_shown: true }
      );
      expect(setIsOpen).toHaveBeenCalledWith(false);
    });
  });

  it('should call handleOrgPreference and close the dialog on successful API call when isOrgPrefernce is true', async () => {
    const setIsOpen = jest.fn();
    (httpPut as jest.Mock).mockResolvedValue({ success: true });

    render(<Disclaimer open={true} setIsOpen={setIsOpen} isOrgPrefernce={true} />);

    // Simulate clicking the "Okay" button
    const okayButton = screen.getByText('Okay');
    fireEvent.click(okayButton);

    // Wait for the API call and dialog close
    await waitFor(() => {
      expect(httpPut).toHaveBeenCalledWith(
        { user: { email: 'test@example.com' } },
        'orgpreferences/llm_approval',
        { llm_optin: true }
      );
      expect(setIsOpen).toHaveBeenCalledWith(false);
    });
  });

  it('should handle API failure and show an error toast', async () => {
    const setIsOpen = jest.fn();
    (httpPut as jest.Mock).mockRejectedValue(new Error('API Error'));

    render(<Disclaimer open={true} setIsOpen={setIsOpen} isOrgPrefernce={false} />);

    // Simulate clicking the "Okay" button
    const okayButton = screen.getByText('Okay');
    fireEvent.click(okayButton);

    // Wait for the error toast
    await waitFor(() => {
      expect(httpPut).toHaveBeenCalled();
      expect(errorToast).toHaveBeenCalledWith('API Error', [], expect.any(Object));
    });
  });

  it('should close the dialog when setIsOpen is called', () => {
    const setIsOpen = jest.fn();

    render(<Disclaimer open={true} setIsOpen={setIsOpen} isOrgPrefernce={false} />);

    // Simulate clicking the "Okay" button
    const okayButton = screen.getByText('Okay');
    fireEvent.click(okayButton);

    expect(setIsOpen).not.toHaveBeenCalled();
  });
});
